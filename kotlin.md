1. Kotlin was *invented* by JetBrains, the people who made Android Studio. It is impossible not to get first-class support for it.
1. There is a repl (called `kotlinc-jvm`), but it's hella slow. [Install with instructions.](https://kotlinlang.org/docs/tutorials/command-line.html)
1. [Kotlin has longer compilation times compared to Java](https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d), with the exception of incremental builds, which may match Java's compile time. So, while developer efficiency goes up (with less boilerplate code), machine efficiency goes down. A fair tradeoff.
1. [`f() ?: g()`](https://en.wikipedia.org/wiki/Elvis_operator) is `f() ? f() : g()`, except `f` doesn't get called twice.
1. Apparently, one of Kotlin's big selling points is [null safety](https://kotlinlang.org/docs/reference/null-safety.html), where normal variables can never point to a `null`. But [`null` is still a thing](https://kotlinlang.org/docs/reference/null-safety.html) and can be explicitly checked and/or allowed (by adding `?` after the variable name declaration). [Saying "no more `NullPointerException`" is **not** true](https://clearbridgemobile.com/java-vs-kotlin-which-is-the-better-option-for-android-app-development/).
1. A [data class](https://kotlinlang.org/docs/reference/data-classes.html) (the Java equivalent would be a generic class with getters, setters, `hashCode()`, and `toString()`?) is built-in, using `data class ClassName(*fields)`. All it does is contain data.
1. A nullable variable cannot have its methods called unless its null-ness is checked (literally, in your code, write `!= null`).
1. **Classes can have multiple constructors**, but only one unique [primary constructor](https://kotlinlang.org/docs/reference/classes.html#constructors). The primary one is just the stuff you put inside `class ClassName constructor(*args)`. All other constructors need to reference the primary constructor one way or the other.
1. `init` blocks are pre-constructor methods. A class can have any number of these, interleved with [pretty much anything you like](https://kotlinlang.org/docs/reference/classes.html#constructors), including statements. *And then* constructors are called.
1. Kotlin does not have a `new` keyword.
1. The default base class is `Any`. All classes implicitly inherit from `Any`.
1. "Overridable" methods are called "open functions", and must be called that to be overridden (e.g. `open fun foo() { ... }`). Overridden methods must also call themselves overrides (e.g. `override fun foo() { ... })`. Like Java, any function that is not open can have `final` in front of it to ensure it is never overridden.
1. Classes *themselves* must also be marked as open/override and final.
1. Properties (i.e. attributes) must also be marked as open/override and final.
1. [A file can contain multiple classes.](https://kotlinlang.org/docs/reference/coding-conventions.html) See also: coding conventions.
1. So Kotlin classes ("KClass") are [not](https://kotlinlang.org/docs/reference/reflection.html) Java classes. To get the reference to a class, use `ClassName::class` (a KClass) instead of just `ClassName`. To get the Java class equivalent, use `SomeJavaClass::class.java` instead.
1. Method calls can seemingly contain bodies for no reason. See this example: `assert(widget is GoodWidget) { "Bad widget: ${widget::class.qualifiedName}" }`
1. A lambda's parameters are declared [**inside** its braces](https://medium.com/@dbottillo/kotlin-by-examples-methods-and-lambdas-25aef7544365), so `onClick({ view -> doSomething() })` is a lambda. If you hate that, you're in luck, because if you don't need any arguments, you can skip `view ->` and make it look like something sane, i.e. `onClick({ doSomething() })`.
1. For some reason, instead of stopping there, kotlin enjoys having function arguments outside the parents *iff it is the last argument of the function call*, so you get `onClick() { doSomething() }` instead. But wait, there's fucking more. If the function call takes just one thing, and that one thing is a function, then you have to skip the parentheses anyway, resulting in the final form: `onClick { doSomething() }`.
1. But if you want to pass in a named function? Fuck you, use parens: `onClick(doSomething)`.
1. The `with(obj, func)` built-in (bearing in mind the last argument is a function, so the lambda stuff above syntactically applies) is the same as [what you used to use in VB6](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/with-end-with-statement): unresolved names are to be found in the object's attributes.
1. Comment styles are the same as the majority of others (`//`, `/* */`).
1. Built-in keywords can be [hard or soft](https://kotlinlang.org/docs/reference/keyword-reference.html). You cannot change hard ones, like `if`/`else`, `class`, and `fun`. You *can* change soft keywords like `file`, `get`, and `set`.
1. ALL functions with blocks, i.e. not a one-liner, need an explicit `return` statement.
1. Because you need to declare parameter types now, the type of a lambda is usually `() -> Unit`, unless they take arguments.
1. The function that accepts a lambda specifies what types the lambda needs to take. The lambdas themselves do not need to (but can) do that.
1. ["In most cases, Kotlin follows the Java coding conventions"](https://kotlinlang.org/docs/reference/coding-conventions.html#formatting), where the [official Oracle Java convention](https://www.oracle.com/technetwork/java/codeconventions-150003.pdf) says "Avoid lines longer than 80 characters ... Examples for use in documentation should have a shorter line lengthâ€”generally nomore than 70 characters."