# Introduction to the Android Platform

1. The instructor is Adam Porter.
1. (...) This course is just one part of a multipart series, or specialization called mobile cloud computing with Android, or **MoCCA**, for short.

# The Android Development Environment

1. ???
1. Didn't watch the vid lol
1. Projects that were created with Eclipse can be *Imported* using "Import Project".

# Application Fundamentals - Part 1

1. Components of an app: **Activity, Service, BroadcastReceiver, ContentProvider**
    * `android.app.Activity`
    * `android.app.Service`
    * `android.content.BroadcastReceiver`
    * `android.content.ContentProvider`
1. Activities typically show a [single] thing the user can do. Activities on bigger screens may display more than one thing.
1. Services run in the background.
1. BroadcastReceivers subscribe to **Intents** that other applications publish.
    * You override `onReceive` in your subclass.
1. ContentProviders uh provide content.
    * ContentProviders can perform interprocess communication.
    * ContentProviders need not be implemented as databases.
    * ContentProviders encapsulate data sets.
    * Android supports several system-wide ContentProviders.
1. **Define resources** (non-code entities): manage your strings and layouts. **Plurals** are string arrays.
    * Define a string with `<string name="string_name">Foo</string>`
    * Resources can be changed without recompiling code.
    * Multiple groups of resources can be created for different device configurations.
    * Compiling an app with resources may be faster than if multiple copies of the same strings were hardcoded.
    * Strings are accessed in layouts with `@string/string_name`, or in code with `R.string.string_name`.
    * **`R`** is an autogenerated `R.java` file. It contains public members like `string` and `layout`.

# Application Fundamentals - Part 2

1. UI **Layouts** are defined in layout files. Use `@layout/layout_name` or `R.layout.layout_name` to access them.
1. Different screen orientations can reference different layouts (`layout`/`layout-land` might be an example-specific setting).
1. Activities should override the `onCreate` method.
1. You create an Activity with `onCreate`. The course quiz will say it is wrong. Skip it.
1. The `onCreate` method should restore saved state, set content view, initialise UI elements, and add events to the UI.
    * `super.onCreate(savedIntanceState)` might be required boilerplate code.
    * `setContentView(R.layout.main)` might also be boilerplate code. `setContentView` sets whichever look (layout) you want to look at.
1. You start an Activity with a `startActivity` method that comes out of nowhere.
1. Packaging information is in `AndroidManifest.xml`.
    * `<manifest>` is the root. Usually.
    * `<uses-sdk>` will be the node you mess up most often.
    * AndroidManifest.xml specifies the app icon and app name.

# The Activity Class - Part 1

1. Activities typically show a [single] thing the user can do. Activities on bigger screens may display more than one thing.
1. **Tasks** are a set of related Activities. These activities do not need to be semantically related.
1. Most Tasks start at the home screen.

## The Task Backstack

1. When an Activity is created, it goes onto the Backstack. Other Activities are suspended.
1. When an Activity is destroyed, it pops off the Backstack. The topmost Activity is then resumed.

## The Activity Lifecycle

1. Activities can be created or destroyed by code, the user (back button), or the system (memory pressure).
1. `onCreate`
    * Calls `super.onCreate()` (restores state)
    * Calls `setContentView()`
    * Gets/retains references to UI elements
    * Adds events to UI elements
1. `onStart`: Activity is "about to be visible"
    * Good for loading some persisted states, like downloading stuff.
1. **Resumed/Running**: visible, user interacting. `onStart`, `onResume`
    * `onResume` is called regardless of state after `onStart`.
    * `onResume` is called when the screen is turned back on when the Activity is in the foreground.
1. **Paused**: [might be] visible, user not interacting, can be terminated `onPause`
    * Can be used to stop foreground behaviours like a video
    * Can be used to persist state
1. **Stopped**: not visible, can be terminated `onStop`
    * In a perfect world, this is called only after an `onPause` was called. This is not the case if the app is killed.
    * Can be used to cache the state
    * Do not persist data here, persist in `onPause`
1. If the Activity is invisible, stopped, but the user goes back to that Activity, then [`onRestart`](https://stackoverflow.com/questions/35476452/when-do-onrestart-method-get-called-in-android) is called instead of `onResume`.
    * Processing of things after stopped
1. **Destroyed**: no longer in memory. Cannot be restarted. `onDestroy`
    * In a perfect world, this is called only after an `onStop` was called. This is not the case if the app is killed.
    * Use to free resources

# The Activity Class - Part 2

## Starting activities

1. `startActivity`: start an Activity. Expect nothing in return.
1. `startActivityForResult`: the Activity will half-assedly provide a result (`setResult()`). The result shows up in an `onActivityResult` in *your* class. This is called a *ShittyCallbackImpl*.
    * Results can have a code, `int resultCode` (`Activity.RESULT_CANCELED`, `Activity.RESULT_OK`, other custom codes).

## Handling configuration changes

1. When keyboard is popped up, orientation is changed, locale is changed, etc., your activity is ~~fucked~~destroyed and recreated. Make sure the two handlers are fast.
1. You can cache some data using the `onRetainNonConfigurationInstance` (deprecated) method, called in between `onStop` and `onDestroy`, and get that data back with `getLastNonConfigurationInstance()` (deprecated) in `onCreate`. The **Fragment** class now handles this.
1. `onConfigurationChanged` will be called when a configuration is manually changed. Specify the configurations you want to manually handle with [`android:configChanges`](https://developer.android.com/guide/topics/manifest/activity-element.html).
1. Avoid handling configuration changes manually. "It is more error-prone," said dude.

## The Intent Class - Part 1

1. Intents are more or less data structures.
1. **Explicit activation**: Intents name the Activity they want to start.
1. **Implicit activation**: Intents don't name the Activity they want to start. Intents name the operation they want to perform; the system then selects the Activity to perform that operation.
1. Intents provide a way to want some work to be done, like "take a photo" or "pick a contact".
1. Intents can also be used to imply that an event has occurred, to represent the event (something like "user clicked share", but not using BroadcastReceivers for some reason).

### Intent fields

1. **Action**: a string that names the operation to be performed. `Intent.ACTION_DIAL` means you want to call a number. `ACTION_EDIT` means you want to edit something. `ACTION_SYNC` means you want to sync. `ACTION_MAIN` means you want to start an Activity as a main Activity of an app.
    * You can either initialise an Intent with the Action, or `.setAction(THE_ACTION)`.
1. **Data**: a URI.
    * Example: `geo:`/`tel:` URIs.
    * You may need to use `Uri.parse()` on these strings first.
    * You can `.setData(THE_DATA)`.
1. **Category**: additional information about the components that can or should handle this Intent.
    * `CATEGORY_BROWSABLE`: can be invoked by a browser.
    * `CATEGORY_LAUNCHER`: can be the initial activity of a task... is listed in the top-level app launcher. (???)
1. **Type**: the MIME type of the Intent Data.
    * Example: `image/png`
    * Set with `.setType(THE_TYPE)` or `.setDataAndType(THE_DATA, THE_TYPE)`.
    * If left unspecified, Android may guess it for you.
1. **Component**: identifies the Intent's target Activity (if you know there is one and only one).
    * This is a `Class`.
    * Set the target Activity with `.setComponent()`, `.setClass()`, or `.setClassName()`.
1. **Extras**: extra information as K-V pairs.
    * The target Activity will have to know how to use it.
    * Set each extra with `.putExtra(EXTRA_NAME, EXTRA_DATA)`.  (overloaded for various types)
1. **Flags**: information about how the Intent should be handled.
    * `FLAG_ACTIVITY_NO_HISTORY`: Once started, the Activity should not be put in the history stack.
    * `FLAG_DEBUG_LOG_RESOLUTION`: Prints extra log information.

## The Intent Class - Part 2

1. Explicit Activation starts an Activity using an Intent with a specific Component. You may construct an Intent with `new Intent(context, class)`. Example: `new Intent(CurrentClass.this, TargetIntent.class)`.
1. Implicit Activation relies on **Intent Resolution** based on the desired operation and **Intent Filters**, the operations that an Activity can handle.
    * IntentFilters are (usually) stored in `AndroidManifest.xml`, in the form of `<activity ..> <intent-filter ..> <action ..><action ..><action ..>`.
    * Each `data` specifies (if desired) the `android:mimeType`, `android:scheme`, `android:host`, `android:post`, ... for each `<intent-filter>`.
    * An IntentFilter that handles maps would have `<data android:scheme="geo" />`.
    * IntentFilters can also have `<action>` and `<category>` children.
    * In order to receive Implicit Intents, an Activity must specify an IntentFilter with the Category `android.intent.category.DEFAULT`.
    * Intent Resolution uses only `data`, `action` and `category` fields. `flags` and `extras` are not used.
1. Intent **Priority**: `android:priority` (from -1000, lowest, to 1000, highest) can be used to specify how high of a priority your Activity should appear to the user by default. The user may override that by choosing something else.
1. `adb dumpsys (package name)` shows all IntentFilters in a package (among other things).